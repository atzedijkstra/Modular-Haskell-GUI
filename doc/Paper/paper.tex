\documentclass[11pt,a4paper]{article}

\usepackage[a4paper,hmargin=3cm,vmargin=3.5cm]{geometry}
\usepackage{listings}
\usepackage{color}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[english]{babel}
\usepackage{lmodern}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{parskip}
\usepackage[breaklinks,pdfborder={0 0 0 0}]{hyperref}



\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}

\lstset{
    escapeinside={\%*}{*)},            % if you want to add a comment within your code
    morekeywords={*,...}               % if you want to add more keywords to the set
}

\makeatletter
\newcommand*\idstyle{\expandafter\id@style\the\lst@token\relax}
\def\id@style#1#2\relax{%
  \ifcat#1\relax\else
    \ifnum`#1=\uccode`#1%
      \relax
    \else
      \it
    \fi
  \fi
}
\makeatother

\lstloadlanguages{Haskell}
\lstnewenvironment{haskell}
{
\lstset{
  language=Haskell,
  keywordstyle=\bfseries,
  basicstyle=\relax,
  stringstyle=\ttfamily,
  commentstyle=\bfseries,
  flexiblecolumns=false,
  showspaces=false,
  showtabs=false,
  showstringspaces=false,
%  frame=tb,
  basewidth=0.55em,
  keywords={forall,case,of,instance,class,data,type},
  identifierstyle=\idstyle,
  literate={+}{{$+$}}1 {/}{{$/$}}1 {*}{{$*$}}1 {=}{{$=$}}1
           {>}{{$>$}}1 {<}{{$<$}}1 {\\}{{$\lambda$}}1
           {\\\\}{{\char`\\\char`\\}}1
           {->}{{$\rightarrow$}}2 {>=}{{$\geq$}}2 {<-}{{$\leftarrow$}}2
           {<=}{{$\leq$}}2 {=>}{{$\Rightarrow$}}2 
           {\ .}{{$\circ$}}2 {\ .\ }{{$\circ$}}2
           {>>}{{>>}}2 {>>=}{{$\gg\!\!=$}}3
           {|}{{$\mid$}}1
           {_}{{\underline{ }}}1
}
}{}


\setlength{\parindent}{0in} 
\setlength{\parskip}{.07in} 







% General parameters, for all pages:
\renewcommand{\topfraction}{1}     % max fraction of floats at top
\renewcommand{\bottomfraction}{1} % max fraction of floats at bottom

% Parameters for TEXT pages (not float pages):
\setcounter{topnumber}{10}
\setcounter{bottomnumber}{10}
\setcounter{totalnumber}{10}   % 2 may work better
\setcounter{dbltopnumber}{10}  % for 2-column pages
\renewcommand{\dbltopfraction}{0.9} % fit big float above 2-col. text
\renewcommand{\textfraction}{0.07}  % allow minimal text w. figs

% Parameters for FLOAT pages (not text pages):
\renewcommand{\floatpagefraction}{0.7} % require fuller float pages

% N.B.: floatpagefraction MUST be less than topfraction !!
\renewcommand{\dblfloatpagefraction}{0.7} % require fuller float pages



\title{Modular Asynchronous Haskell Graphical User Interface}

\author{Bert Massop \texttt{<B.Massop@uu.nl>}\\
Gerben van Veenendaal \texttt{<gerbenvv@gmail.com>}}

\begin{document}

\maketitle

\newpage
\tableofcontents

\newpage
\section{Goal}

While there are already quite some Haskell graphical user interface libraries, they can be hard to use or maintain.
Some libraries have a lot of dependencies and are therefore hard to build, some feature a monolithic design making it hard to replace functionality as needed.
Because of this updating to a new version of a user interface can be painstaking and this makes creating a simple application with a user interface in Haskell a tedious process.
We want to overcome these problems by creating a new user interface library, that should have the following features:

\begin{itemize}
\item It has to be standalone, no external non-Haskell dependencies should be used.
\item The API should be easy, preferably it should be similary to a currently widely used user interface API's.
\item It has to be cross-platform, preferably usable on mobile devices and tablets as well.
\item It has to have modern features that other current user interface libraries also have.
\item It has to be modular, so that we can easily swap a part of the library with another part.
This also makes the library future proof.
\end{itemize}

Our goal is to create such a user interface library for Haskell using modern technology.
The question we asked ourselves was: can this goal be achieved, and what technical difficulties should be solved in order to do this.

\section{Related work}
\subsection{wxHaskell}
wxHaskell is a widely used Haskell GUI framework based on wxWidgets, a portable C++ GUI library.
It features a complete implementation of the wxWidgets interface using phantom types to model the hierarchical inheritance, while existential quantified types allow for a usable approach to setting attributes.\cite{leijen2004wxhaskell}
This approach to attributes makes wxHaskell both powerful and easy to use.

wxHaskell is not modular in any sense, and can therefore only be used with the wxWidgets library.
Sadly, this combination has proven to be hard to compile, depending on the target system, making the framework less portable than intended.
Also, since wxHaskell ties the GUI to the same machine as the running application, it cannot genuinely be used on most mobile devices.

\subsection{Gtk2Hs}
Gtk2Hs is a Haskell GUI framework based on GTK+, another portable C++ GUI library.
It is quite similar to wxHaskell, though it is a little less refined.\cite{vanbuilding}
Gtk2Hs is more or less an exact representation of the GTK+ API in Haskell, adding some functions for casting values.
Still, Gtk2Hs is interesting as it allows interfaces to be designed graphically through Glade, a drag-and-drop design tool.

\subsection{iData/iTasks}
iData is an experimental web-based user interface framework written in Clean.
iData takes an entirely different approach to user interface interaction than wxHaskell and similar frameworks, by providing a thin client architecture.
This architecture separates the GUI from the application logic.
In iData, a regular web browser rendering HTML objects performs the GUI role, while the application creates these HTML objects by means of a combinator language.

iTasks is an extension to the iData system.
Instead of focusing on the layout specification, the focus is on the information chain of interaction with (or choices by) the user(s): the \textit{work flow} of \textit{tasks}.\cite{plasmeijer2007itasks}
A combinator language lazily specifies the task tree for the application.
After a connection loss or page refresh, the task tree can be restored and the work flow can be resumed.
Another unique capability of iTasks in Clean is the possibility to offload computations to the client on demand, utilizing serialization based on dynamic language elements in Clean.\cite{jansen2010embedding}

Both iData and iTasks are specifically designed to be used with HTML rendering intents, an application explicitly generates HTML through the combinator language.
While HTML allows mobile devices to use the system, a complete rewrite of both library and application are needed to, for instance, support a true native rendering solution.

\section{Technology}

In order to create a brand new user interface library that meets our requirements, we first need to look at the possibilities that are currently available to do so.
This chapter walks through the choices of what existing technology to use to create the library.

\subsection{The browser}

As the browser is today the most used interface for most people, we wanted to leverage that.
Everybody has a browser as it provides an easy way to browse the web and use your favorite web applications.
Most applications move to the \textit{SaaS} (Software as a Service) software delivery model.
Browsers are also installed on mobile devices like smart phones and tablets, so by targeting the browser, we target almost all existing platforms.

When you use the browser, you are bound to using a few web languages:

\begin{itemize}
\item \textit{HTML} (HyperText Markup Language) -- A markup language used to structure content in a browser.
Content can be images, text, boxes, vector graphics, etc.
\item \textit{CSS} (Cascading Style Sheets) -- A styling language to provide the styling for the structured content.
Provides ways to for example give text a color, give boxes a location, etc.
\item \textit{Javascript} -- A scripting language that provides means to interact with the user.
It can add, modify and remove structure (HTML) and styling (CSS). Javascript has an event based model, it can only do something when an event has happened like a mouse movement or a key press.
There is no main loop.
You can however install intervals to run code regularly.
\end{itemize}

Basic knowledge about these languages is assumed in this paper, so we won't explain them in detail.
As we can see the browser is powerful enough to build a user interface.
We can do this by creating widgets (eg: a button) that have a certain structure (HTML) and styling (CSS).
We can then add interaction to the widget by adding events on which Javascript is run.
Therefore, we decided to use the browser for our new user interface library.
This also implicates that we use HTTP to serve the required HTML, CSS and Javascript to the browser.
As HTTP is a stateless protocol, we had to make the user interface work asynchronously.

\subsection{Communication}

So we have established that we want to use the browser and Haskell for the user interface library.
But how do these two communicate?
For the user interface to work we need a two-way communication because user events must be sent to Haskell and visual changes must be sent back to the browser.
It seems we have the following options:

\begin{itemize}
\item \textit{Polling} -- Polling is a technique that does a HTTP request on a regular interval.
The requests ask the server if they have any pending messages for the client, and if so, they are returned. Messages from the client to the server can be immediately sent.
Polling is very bandwidth heavy, and the delay between the time the message is ready on the server and the time the request is made can be as large as the interval time.
\item \textit{Long polling} -- Long polling is a technique that essentially does the same thing as polling, but the server waits to respond until there is a message ready at the server.
If there is, the message is returned and a new request is made from the client.
The problem is that when a lot of messages are sent from the server, a lot of requests must be made from the client.
This can quickly go out of control and results in a lot of bandwidth usage and delay.
\item \textit{Streaming} -- Streaming is a technique that creates a request to the server and the server keeps this request open.
When a message is available, it is sent to the client, but the request is not closed.
Whenever messages are ready, they are sent to the client over the open request.
This technique works fairly well, but it does not always work.
Firewalls and intermediate proxies may buffer the response from the server resulting in a significant delay.
\item \textit{WebSockets} -- A relatively new technique is the new HTML 5 feature WebSockets.
WebSockets are HTTP requests which are upgraded to a two-way TCP connection over which messages can be sent that use the WebSocket protocol.
Messages are very lightweight.
Not all browsers support WebSockets however, but you can use a Flash based alternative if there is no support.
If you use port 80 there can still be a problem with intermediate proxies that buffer or do not support the WebSocket protocol.
You can however use a different port.
In that case the firewall at the client must not block that outgoing port.
On most machines most outgoing ports are not blocked, so that is almost never a problem.
\end{itemize}

\newpage
It is quite clear that the WebSocket solution is the best solution there is.
In time, WebSockets is likely to be implemented by more browsers (currently only Chrome and Firefox support it) and be used by more people.
Also, because this is a cutting edge library, we want to use the newest technology.
For the browsers that do not support WebSockets we use the Flash alternative.

\newpage
\section{Layers}

To model the modularity of the entire library, we chose a layered approach.
With this approach the library is divided into a stack of separate modules or layers, which can only communicate with the layers above and below them.
Each of the layers is fully replaceable with an equivalent layer which makes the library future proof.
We will go into more detail about the layers in the next chapters.

\subsection{Application layer}
The \textit{application layer} is the layer in which the application logic utilizing this framework resides.
The application can use the API layer, as described below, to access GUI functionality.

\subsection{Application Programming Interface layer}

The \textit{API (Application Programming Interface) layer} is responsible for communication between the application that uses the library and the library itself.
It has to be easy to use, yet powerful enough to create all kinds of user interfaces.
This layer is written as a Haskell module, providing the necessary functions and types to create and operate a GUI.

The API layer also contains a widget abstraction, defining which widgets exist and how they operate.
This abstraction has to match the client-side widget abstraction layer, ensuring that the client-side abstraction provides at least the widgets as promised by the server-side widget abstraction.
The API layer does however not know anything about the actual rendering of the widgets.

More about this layer can be found in the chapter on the server-side implementation.

\subsection{Server-side communication layer}
The \textit{server-side communication layer} communicates the function calls that the user makes in the API over the transmission layer.
It uses the transmission protocol for this as described later on.
All transmitted messages are formatted using \textit{JSON}
JSON is a subset of Javscript.
This allows for easy parsing in Javascript on the client, and it is easy to understand and implement.
The server-side communication layer is written in Haskell.

\subsection{Transmission layer}

The \textit{transmission layer} handles the actual data transfer between client and server.
It uses the WebSocket protocol to send data over the line.
This layer is actually split over the client and the server.
The server part of the transmission layer is written in Haskell, the client part in Javascript.
Part of the transmission layer on the client lies in the browser itself, Javascript uses an API to create a WebSocket connection.

%TODO: the transmission layer does not really speak HTTP. That's all static stuff.
%The server must also have a simple HTTP server to serve the HTML, CSS and Javascript files to the browser.
%This HTTP server does not need to do very much, except for handling static file requests and handling caching.

\subsection{Client-side communication layer}

The \textit{client-side communication layer} is the counterpart of the server-side communication layer.
It sends events that happen on the client to the server and receives data from the server from which it builds a user interface on the client.

\subsection{Client-side widget abstraction layer}

The \textit{widget layer} actually defines what the user interface looks like and what its possibilities are.
It is very thick, it only receives a high-level description of a user interface and builds a user interface from that.
It supports many different widgets and it supports theming.
It also has a very easy to use Javascript API, and can therefore easily be used apart from the rest of the stack as alternative Javascript user interface.
It has features that are comparable to large application user interface libraries like Qt and GTK+.
% More about this layer can be found in the client-side chapter.

\newpage
\section{The client-side}

The client-side consists of a widget layer, a communication layer and a transmission layer.
In this chapter we will look at them in more detail.

\subsection{Class system}

\subsubsection{Prototypal inheritance}
When working with Javascript, it's important to know that Javascript is by itself not a class-based language.
It has a very powerful feature called \textit{prototypal inheritance}.
This means that you can create prototypes, which are objects, and give it some members.
You can then create an object that is based on that prototype object, thereby inheriting all the members of the prototype.
In Javascript this can be done by the setting the special \textit{prototype} member and then by using the \textit{new} operator.

\subsubsection{Hierarchical class system}
We wanted to hide all these nitty-gritty details and build a hierarchical class system on top of this prototype system.
This is very doable and many other libraries do it these days.
We have made a system that is very easy to use, readable, and is yet very powerful.
It allows you to create a new class with the following syntax:

\begin{verbatim}
Class.define('SomeClassName', {
    extend: 'ClassToExtendFrom',
    
    construct: function(a, b, c)
    {
    		// Construction of the object.
    },
    
    someOtherMember: function(a, b)
    {
        // Method body.
    },
    
    statics: {
        someStaticMember: function(a, b)
        {
            // Static method body.
        }
    }
});
\end{verbatim}

\newpage
As you can see statics can be provides with the special \textit{statics} member.
The class above can be instanced and used as expected:

\begin{verbatim}
var obj = new SomeClassName(1, 2, 3);

obj.someOtherMember(1, 2);

SomeClassName.someStaticMember(1, 2);
\end{verbatim}

\subsubsection{Singletons}
Singletons are also supported and can be created with:

\begin{verbatim}
Singleton.define('SomeSingleton', {
    someMember: function(a, b)
    {
        // Method body
    }
});
\end{verbatim}

Singletons only have one instance and that instance is immediately created.
The instance can be accessed by the class name:

\begin{verbatim}
SomeSingleton.someMember(1, 2);
\end{verbatim}

\subsection{High level description}

When creating a user interface, you have to decide how much the client does, and how much the server does.
The choice made is reflected in how much is done at the client, and how much is sent over the network.
We chose to put quite a bit of logic on the client.
We created a high level description of a user interface, which is sent to the client.
The client then creates a user interface from that.
That way, because it is a high level description, not much is sent over the network, and consequently, not much bandwidth is used.
We could have also chosen to send a low level description of the user interface (eg: bitmaps) to the client.
This would have resulting in the client being thin, and a massive usage of bandwidth.
A high level description comes with one trade-off of having duplicate logic: the client and the server both need to know the details of the description.

\subsection{Widgets}

We chose the high level description to be widgets.
Widgets are the entities that are used to build a user interface.
They are the building blocks of which everything you see on the screen consists.
Examples of widgets are buttons, windows, menu bars and boxes that horizontally lay out other widgets.
The widgets are a hierarchy, for example a CheckButton is a Button, and a CheckMenuItem is a MenuItem.
Widgets have the following features:

\newpage
\begin{itemize}
\item \textit{Properties} -- A property is a piece of state of the widget.
A window for example has a title property, which is a string, and label has a text property.
Properties can be read-only.
Properties are inherited, so that subclasses automatically have the properties of their superclasses.

\item \textit{Actions} -- An action is like a method of the widget.
It does some calculation and changes multiple properties at once.
Actions are available to reduce the amount of repetitive code that the user of the library has to use.

\item \textit{Signals} -- Signals are named events that the user can hook into.
Examples of signals are: a key press on a focussed widget, a mouse click on a button, a change of the text of an input field, etc.
It implements the observer pattern.
This pattern allows the user of the library to hook into signals that he would like to act upon.
Property changes generate a signal as well.
This is very powerful and is used to send new properties to the server if they are changed.
\end{itemize}

\subsection{Tree structure}

Widgets form a tree structure.
On the top of the tree is either a Window widget or a MainWindow widget.
The Window widget is a a simple window that you can drag around, maximize, resize, etc.
The MainWindow widget is the widget that covers the whole browser viewport.
It cannot be dragged around or maximized or in any way interacted with.
You can of course interact with its child widgets.
You can separate the available widgets into two groups: those that can have child widgets and those that cannot.
For example a Window widget can contain a single widget as its content, and a button can contain any widget as well.
We call such widgets container widgets.
Examples of widgets that cannot contain other widgets are the Label widget, the ProgressBar widget and the Slider widget.
These widgets occur at the bottom of the tree.

The container widgets can be separated into two groups as well, those who can only contain a single widget, and those that can contain multiple widgets.
The first group are the Bin widgets.
The other group are the layouting widgets.
They lay out their child widgets on the screen in a certain way.
The currently implemented layouting widgets are:

\begin{itemize}
\item \textit{Box} -- The Box widget lays its children out horizontally or vertically.
The \textit{orientation} property determined whether it is a a horizontal or vertical box.

\item \textit{ButtonBox} -- A ButtonBox is a subclass of Box and is meant to lay out buttons, for example in a dialog window.
It gives each button the same width or height depending on its orientation.
It has powerful button alignment options.

\item \textit{Fixed} -- The Fixed layouting widget puts its children at fixed coordinates.
It is not recommended to use this, because the children their size and position will be static, even though more size may be available for them.
\end{itemize}

\subsection{Size management}

Size management determines how much size every widget gets.
It starts at the top level widget which is a Window or MainWindow.
It then traverses the tree of widgets and allocates each widget a size, keeping in mind their minimum and preferred sizes.
The minimum size is the absolute minimum size of a widget, it cannot be made smaller.
The preferred size is the size the widget would like to be.
It must be larger than its minimum size.
Minimum and preferred sizes are for container widgets often dependant on the child widgets.
For example if you take a Box widget that lays its children out horizontally, you add the child widgets its minimum width, and take the maximum of their minimum heights.
The result is the minimum size of the Box widget.
So although the actual size allocation is top-down, the determination of the minimum and preferred sizes is bottom-up.

Every widget has the following layouting properties:

\begin{itemize}
\item \textit{h-scale} and \textit{v-scale} -- These properties determine the horizontal and vertical scale of the widget.
If the h-scale is 1, the widget will take up the full size in the horizontal direction that is allocated to it.
If it is 0, the widget will take up its minimum horizontal size.
It can also be anything in between.

\item \textit{h-align} and \textit{v-align} -- These properties determine the alignment of the widget in its allocated space.
They only have effect when the scale of the widget in the alignment direction is less than 1.
If the h-align is 0, the widget will be aligned to the left and if it is 1, it will be aligned to the right.
It can also be anything in between.

\item \textit{margin}, \textit{margin-top}, \textit{margin-right}, \textit{margin-bottom} and \textit{margin-left} -- These properties determine the margin around the widget.
The \textit{margin} property sets all margin properties at once to a certain value.
You can use the others to specify a specific margin for a widget side.
The margin is always visible outside of the widget.
It will be automatically added to the minimum and preferred size of the widget.
\end{itemize}

These properties are automatically handled by the widget system, so by implementing a new widget you do not have to handle these properties.

\subsection{Rendering}

The rendering process of a widget is the process of showing the widget in the browser in its current state.
Every widget has its HTML structure in the Javascript code as a static string.
This HTML is used to put the widget in the DOM (Document Object Model) of the browser in order to render it.
Because browser rendering behavior and the DOM API is very different among browsers, we had to make a DOM element abstraction class.
This class represents a single HTML element and has properties to change the attributes, styling and contents of the element.
Changing the DOM elements of a widget to the current state happens on size allocation.
When a size is allocated to a widget, it calculates all the sizes of its elements and applies them.
Most changes to the DOM are positioning and sizing changes, which are quite expensive.
In order to optimize reading the position and size of an element, they are cached in the element object.
That way, a size allocation of a widget does just writes to the DOM and no reads, which speeds up the rendering a lot.

\subsection{Focus system}

\subsubsection{Focus types}
The focus system in a user interface takes care of which widgets has the focus and changing the focus.
There are two types of focus:

\begin{itemize}
\item \textit{Window focus} -- Window focus is the determination of what visible window has the focus.
At most one window can have focus at a time.
Within the focussed window there is at most one focussed widget.
The main window which covers the whole browser viewport is just another window, it may have focus as well.
By clicking on the window the window gets focus.
This happens before the mouse down event gets sent to a widget within the window.

\item \textit{Widget focus} -- Widget focus on the other hand is the determination of what widget within the focussed window has the input focus.
This can be any widget, but mostly they are input widgets and buttons.
A window always stores the last focussed widget, so that when it loses window focus and gains it again, it can focus the widget that had focus before.
Widgets can be made insensitive so that they and their children can not receive focus any more.

\end{itemize}

The focus system implements this system, and makes it so that only one widget within a window can be focussed.
It also takes care of changing the focus: by tabbing you cycle between the focusable widgets.
This cycle is determined according to the widget tree structure.
First a widget tries to gain focus itself, then if that fails it tries to focus its children and so on. 

\subsubsection{Browser support}

When working inside the browser you want to leverage the features of the browser as much as possible.
In the browser, you can make an element focusable by giving it a non-negative \textit{tabindex} attribute.
However, quite a few problems with this approach arise.
First off, the browser iterates through all widgets that are focusable, even though they may be inside different windows.
This can be fixed by only making the widgets under the focussed window receive focus, but that requires a lot of changes to elements on each change of window focus.
Secondly, the browser also iterates through its own menus and input fields like the address bar.
Thirdly, in a browser it may be the case that no element and thus no widget has focus at all.
This is not wanted in an application user interface.
Finally, some browser do not specify where the focus came from or went to on a focus change event.
These points are problematic, and so we did not use the browser its focus functionality to create the focus system.
Instead we hooked into the tab key, and implemented the whole focus system ourselves in Javscript.

\subsection{Event system}

In order to create a user interface, you need to have a powerful event system.
Events are signals that widgets get when a user has interacted with a widget with the mouse or keyboard.
Examples of events are when the user scrolls over a widget or presses a key.
In most user interface libraries mouse events get sent to the widget under which the cursor currently is and key events get sent to the widget that has input focus.
Widget events can be hooked into by connecting to event signals.

\subsubsection{Event capturing and bubbling}

Events have a source from which they originate.
However, as the widgets form a tree structure it is not always clear what the origin of the event is.
For example, for mouse events the source widget is the widget that is currently under the cursor.
But all the parents of that widget are also under the cursor.

In order to solve this, events are usably sent to multiple widgets in two phases: the \textit{capturing phase} and the \textit{bubbling phase}.
The capturing phase is the phase in which the event is sent to all parent widgets of the source widget in a top-down manner.
Any widget may choose to handle the event in this phase which stops the event from being sent to other widgets.
This phase is handy to prevent (certain) events from reaching child widgets.
The next phase is the bubbling phase, in which the event gets sent to the source widget and then to all of its parent widgets in a bottom-up manner.
Again, the event can be stopped anywhere in this phase by handling the event.
For example when a user scrolls over a Slider widget, the slider will change its value.
The slider has handled the event, so it will not bubble up.
If the user scrolls over a label however, the label will not handle the scroll event and it will bubble up.
It may then for example reach a ScrollArea widget which will handle the event and scroll its contents according to the event.

\subsubsection{Browser support}

In order to create this event system, we had to leverage the event system that the browser had to offer.
This was not an easy task however, as all browsers implement the event model differently.
For example, most browsers implement event capturing, but older version of Internet Explorer do not.
There is also very inconsistent behavior among browsers of the doubleclick event.
Finally there is a lot of inconsistent behavior with key events.
% Most key combinations are unusable because they already have a meaning in the browser. (eg: CTRL + P).

We had to implement the whole capturing and bubbling phases ourselves in Javascript.
In order to do this, we set the widget as a property on the element that it uses.
We hook into every event type on the body tag, so that we get every event.
Then we read the source element from the event, and its widget property.
After this we create a custom event object that abstracts the browser event and run the capture and bubble phases.

\subsubsection{Focus events}

As we have a custom focus system, we cannot use the focus and blur events of the browser.
Focus events are therefore syntactically created and sent to the widget chains.
The event system also adds the related widget on focus and blur events, which is the widget that just lost and just gained focus respectively.

\subsection{Theming}

Themability is an important aspect of a user interface.
Our user interface is fully styled with CSS.
CSS is purely a styling language, it does not have any programming concepts like variables, conditions or functions.
Therefore, we have chosen to use SCSS for the styling.
SCSS is a programming language on top of CSS to make styling programmable.
SCSS supports variables, conditions and functions.
Its syntax is much like CSS, in fact, CSS is a subset of SCSS.

Our styling is separated into two categories: base styling and theme styling.
Base styling styles the absolute bases for the widgets, which will most likely not be overriden by the theme.
It consists mostly of basic positioning of the widgets.
Also, it normalizes the browser its default styling of elements, as that is different per browser.
Finally it provides cursors to use by the user interface.
Theme styling provides the colors, background images, fonts, etc. for the user interface.
Every widget has a unique class, so that each widget can be styled differently.
The styling of the widgets relies on the HTML structure of the widgets, which is specified in the Javascript.
If the structure changes, the styling must be changed, so the structure has been made very generic to allow all kinds of different themes.

We have made one theme for the user interface: the clearlooks theme.
It's basically the same as the clearlooks theme for GTK+.
Because SCSS allows for variables, everything can be changed by a few variables.
Things like the base color, secondary color and the font can all by changed easily this way.
We have also made a build script that builds the CSS from the SCSS and colors the theme images according to the base color.
The coloring is done by replacing the hue of the colors in the image with a the hue component of the new base color.

\subsection{API Documentation}

So support the users that will be using this user interface, good API documentation needs to be provided.
We did not want to do this manually, as the API is very likely to change in the future.
Also, it would be very repetitive and boring work.
So we decided to create an API documentation generator which reads the API from the source code and generates a series of HTML documentation files from it.
The generator automatically reads the widget hierarchy from the source code.
The generator uses a Doxygen-like syntax which works by providing explaining comments above widget properties, signals and actions.

\newpage
An example comment of the \textit{visible} property of Widget:
\begin{verbatim}
/**
 * Whether the widget is visible.
 *
 * @type int
 * @see #show()
 * @see #hide()
 */
visible: {

...

}
\end{verbatim}
As you can see it also provides the type of the property and adds references to some actions.

\subsection{Transmission}

The previous sections have described how the widget layer is implemented.
An important task left is of course the transmission to and from the server.
That's where the transmission layer kicks in.
This layer implements the communication protocol as described later on.
It uses a connection object to abstract the details of the WebSockets away.
That way, we can easily choose to use another way to communicate in the future.
The WebSocket API is emulated on browsers that have no WebSocket support with a Flash TCP connection that implements the WebSocket standard.

The transmission layer is completely separate from the widget layer.
It uses the API of the widget layer to implement the protocol.
When properties of widgets are changed, signals are sent which can be hooked in to.
The transmission layer does this for every widget and sends the new value of the property to the server.

\newpage
\section{The communication protocol}

We needed an abstract protocol to communicate the user interface over the network.
This protocol does not describe the means of transmission, in our case WebSockets.
It just describes a message based protocol that describes how user interfaces are built, how signals are communicated and how properties are sent.
It does not talk about widgets, but about objects. Objects can be more that just widgets, they can also be helper classes that are needed for the user interface.

\subsection{Some definitions}

First we want to explain some definitions that we are going to use in the protocol:

\begin{itemize}
\item \textit{Object} -- A user interface entity. Object can be singletons or user created objects. Examples are: a button, window or label.
\item \textit{Singleton} -- An object that has only one instance which always exists.
\item \textit{Identifier} -- Every object has an identifier.
This is unique number that can be used to identify the object.
Singleton identifiers are below 1000.
User-defined objects have an identifier of at least 1000.
\item \textit{Property} -- A single piece of state of an object. Some properties can be read-only.
Examples are the text of a label, the title of a window or the pressed state of a toggle button.
\item \textit{Action} -- An action is a method of an object that can be run.
Actions almost always change the state of one or more widgets.
Actions have some logic around the state.
Examples are: the add action on a window to add a child widget.
\item \textit{Signal} -- A named event on the client.
A signal has an object as origin and can have arguments.
\item \textit{Server} -- The server actor of the protocol.
Has the application logic behind the user interface.
Determines what objects are used and what the state is of the objects.
Sends actions and properties to the client.
\item \textit{Client} -- The client actor of the protocol.
Shows the objects with their properties and runs actions on them.
Sends the signals of the objects to the server.
Also sends changed properties to the server.
\item \textit{Connection} -- Pipeline over which messages are sent from client to server and vice versa.
Can for example be TCP/IP.
\item \textit{Message} -- A single piece of information that is exchanged between client and server.
The connection is bidirectional, so message can come from both the server and the client.
\end{itemize}

\newpage
\subsection{Connection states}

The protocol goes over a connection, which can be in different states on the client:

\begin{itemize}
\item \textit{Connecting state} -- The connection with the server has been made, but no handshake has happened yet.
\item \textit{Handshake state} -- The establish message has been sent, but nothing has been sent back yet.
\item \textit{Established state} -- The connection has been fully established.
\item \textit{Closed state} -- The connection has been closed by either the server or the client.
This can be caused by a connection time-out, an error or a close message.
\end{itemize}

The state can only change to a next state or to the closed state.

\subsection{Message formatting}

Single messages are formatted using JSON.
Messages are always objects.
Multiple messages can be sent by putting them in an array:

\begin{verbatim}
[{ message 1 },{ message 2 },{ message 3}]
\end{verbatim}

A message always has the property \textit{type}, which is used to identity the type of the message.

\subsection{Connection management}

The connection is established by the client.
In order to do this it first connects with the server.
Then it sets the connection state to \textit{connecting}.
Then it sends an \textit{establish} message:

\begin{verbatim}
{
    "type": "establish",

    "exts": ["some-extension", "some-other-extension"]
}
\end{verbatim}

As you can see the only property that this message has besides the type property is the \textit{exts}.
This is an array with a list of strings that are the extensions of the client.
These extensions can be used to extend the protocol and therefore make it future proof.
After sending this message the connection state should be set to \textit{handshake}.

The server should in case of a success send the \textit{acknowledge} message back:

\begin{verbatim}
{
    "type": "acknowledge",

    "exts": ["some-extension", "some-other-extension"]
}
\end{verbatim}

The \textit{exts} property here indicates which extensions should be actually used of the list the client sent.
This can be implemented to be the intersection between the the client its extensions and the server its extensions.
After receiving this message the connection state should be set to \textit{established}.

In case of any error, the \textit{error} message should be sent:

\begin{verbatim}
{
    "type": "error",

    "msg": "Something went horribly wrong."
}
\end{verbatim}

The \textit{msg} property must be a string message describing the error.
Only one of these message can be sent back by the server.

To close the connection the client or server can always sent a \textit{close} message:

\begin{verbatim}
{
    "type": "close"
}
\end{verbatim}

This message has the same effect as just closing the connection, but is more graceful.
The error message should be handled just like a close message and just like a connection loss on the client: the connection should be closed and the connection state should be set to \textit{closed}.

There is a connection time-out of 60 seconds on the connection.
If no messages are sent within that time, the connection should be closed.

A \textit{keepalive} message should be sent to the server every 10 seconds, if no other message has been sent meanwhile.
This message prevents closing the connection. It looks like:

\begin{verbatim}
{
    "type": "keepalive"
}
\end{verbatim}

\subsection{Object creation}

The server can sent a \textit{create} message to create a new object on the client.
Create messages look like:

\begin{verbatim}
{
    "type": "create",
    
    "class": "SomeClassName",
    "id": 12
}
\end{verbatim}

The \textit{class} property determines the class of the object to be created.
The \textit{id} property gives the new object an identifier.
This identifier must be a unique positive integer of at least 1000.
The identifier can be used by other message to refer to the newly created object.
Nothing should be sent back to the server, except for an error message if an error occurred while creating the new object on the client.

\subsection{Property setting}

After creation of an object, object properties can be set with the \textit{set} message:

\begin{verbatim}
{
    "type": "set",
    
    "id": 12,
    "name": "some-property-name",
    "value": "some value"
}
\end{verbatim}

The \textit{id} property indicates the unique id of the object to set the property of.
This id must be of a newly created object or of an existing singleton.
The \textit{name} property is a string indicating the name of the property to change.
The \textit{value} property is the new value of the property.
It can have any type the property support.
If an error occurs on the client, it should send an error message.

This message should also be used when some property changes on the client.
The client should then send a set message to the server with the new property value.

\subsection{Running actions}

The server can also run actions on objects.
This can be done by sending an \textit{action} message:

\begin{verbatim}
{
    "type": "action",

    "name": "someActionName",
    "id": 12,
    "args": [
        10, "foobar", true
    ]
}
\end{verbatim}

The \textit{name} property is the name of the action to be called.
The \textit{id} property indicates the target object identifier to call the action on.
The \textit{args} property is an array containing the arguments of the action to call.

\subsection{Event signalling}

When something happens on the client that the server should know about the client should send a \textit{signal} message:

\begin{verbatim}
{
    "type": "signal",

    "name": "some-signal-name",
    "id": 12,
    "time": 8192381290381,
    "args": [
        10, "foobar", true
    ]
}
\end{verbatim}

The \textit{name} property is the name of the signal that has happened.
The \textit{id} property indicates the source object from which the signal came.
The \textit{time} property contains the time at which the signal happened.
It must be the amount of milliseconds since epoch in UTC.
The \textit{args} property is an array containing the arguments of the signal.

\subsection{Value format}

Whenever values are transmitted, so the \textit{args} and \textit{value} properties, references to objects must be converted to the following representation:

\begin{verbatim}
{
    "id": 12
}
\end{verbatim}

Where the \textit{id} property is the identifier of the object referenced.
Other than these object references, there must be no object in a value.
So the only values allowed are integers, doubles, booleans, strings, nulls, object references and arrays of allowed values.

\newpage
\section{The server-side}

Since the goal is to make a modular design, the server-side code has been designed to be as modular as possible.
Therefore, apart from the separation between API and communication layer, the code has been split into several modules.
All modules are in the \textit{Graphics.UI.WebGUI} module namespace.

\subsection{Transmission layer}
The transmission layer starts some kind of service devoted to actually receiving data from the client and transmitting it vice-versa.
It is responsible for accepting new WebSocket connections, after which it should spawn the other layers.
The \textit{Server} module defines an interface for the transmission layer.
\textit{Server.Websocket} is a functional Websocket transmission layer, utilizing the \texttt{websockets} package.

\subsection{Communication layer}
The communication layer translates the raw JSON strings received from the client to proper datastructures or \textit{Tokens}, and vice-versa.
Its sole purpose is to make sure the other layers do not have to speak JSON.
This layer, implemented as module \textit{JSON}, utilizes the \texttt{json} package for JSON manipulation and parsing.

Due to the static typing of the Haskell application and the lack of types in JSON, translation involves knowledge about the inner datastructures.
Still, this layer does not know anything about the semantics of the received values.
It only knows about which fields are required for which kind of message, and of which type they are: for each kind of message, there exists a token to represent it.
The communication layer is thereby only the first step in transforming non-typesafe data received into typesafe data.

The generated tokens are transfered by means of \textit{Buffer}s, implemented as STM \textit{TBChan}s, between the communication layer and the API layer.
This allows the transmission to be performed asynchronously.

\subsection{API layer}
The API layer bridges the gap between the communication layer and the application layer.
This layer is composed of several different modules, each modeling different knowledge about the system.

\subsubsection{Type abstractions}
To comply with the strict typing rules of Haskell while not loosing too much modularity, we often pass the type of the implementation as a type argument to the abstract object.
We have, for example, the \texttt{Object} datatype.
This type is used to carry several state variables in the implementation of the internal GUI logic, and is therefore highly implementation specific.
To maintain separatable modularity, we do for instance not want the widget abstraction module to depend on the internal GUI logic module.
For instance, we represent widgets with an additional type and constructor argument, containing the internal object representation.
We can then make the abstract object a transitive instance of a type class, if we demand the type argument to be an instance of the same type class.

In module \textit{GUI}, the internal implementation:
\begin{haskell}
data Object = Object Type Identifier Global
instance EventObject Object Event where
    on (Object t i g) e f = [Implementation Omitted]
\end{haskell}

In module \textit{Widgets}, the abstract widget object:
\begin{haskell}
data ObjectT a b = O { obj :: b }
instance EventObject b Event => EventObject (ObjectT a b) Event where
    on (O b) = on b
\end{haskell}

\subsubsection{Widgets}
In a GUI, widgets form a strict hierarchical tree of inheritance, where imperatively speaking, the child is a subclass of the parent.
In Haskell though, there is no straightforward way to express inheritance like we know from imperative languages.
Gtk2Hs solves this problem by providing explicity casting functions, while wxHaskell solves this problem in a more elegant fashion by leveraging phantom types.
We will adopt the latter approach.
The following example shows the \textit{ObjectT} at the top of the hierarchy, with \textit{Widget} immediately below, followed by \textit{Container} and \textit{Box} (the \textit{b} type argument is an implementation abstraction like described above):
\begin{haskell}
type Widget a b = ObjectT (AbstractWidget a) b
data AbstractWidget a = AbstractWidget

type Container a b = Widget (AbstractContainer a) b
data AbstractContainer a = AbstractContainer

type Box a b = Container (AbstractBox a) b
data AbstractBox a = AbstractBox
\end{haskell}

The \textit{a} type argument captures the exact inheritance tree of each type.
This means that as long as a function taking a \textit{Widget a} does not care about the \textit{a} type argument, it can as well accept Containers and Boxes.
This can be illustrated by the type-checker equivalence of the following definitions:
\begin{haskell}
box :: Box a
box :: Container (AbstractBox a)
box :: Widget (AbstractContainer (AbstractBox a))
box :: ObjectT (AbstractWidget (AbstractContainer (AbstractBox a)))
\end{haskell}

The \textit{Widgets} module specifies all widgets the GUI system knows about, and models the properties and actions that can be performed on the respective widgets.
Therefore, the \textit{Widgets} module depends on the \textit{Properties} and \textit{Actions} module that define available properties and actions.

It should of course also be possible to construct a new Widget or similar object using the API.
This module therefore implements several \textit{new}XXX functions.
\begin{haskell}
newWindow :: New Window
newWindow = new windowDefaults

type New obj = (ProtoWidget (obj () o),
                NewWidget o (obj () o),
                PropertyObject o) =>
                  Screen () o -> IO (obj () o)

class ProtoWidget w where
  widgetClass :: w -> String

class NewWidget o t where
  new :: ProtoWidget t => [Setting t] -> o -> IO t
\end{haskell}

Note that the first argument of \textit{newWindow} is not the parent-to-be, but a \textit{Screen}, some representation of the current user connection.
This allows running multiple instances of the same application at once, all started on demand by an incoming connection.
Note however that it is the responsibility of the application author to let these instances cooperate if that behaviour is intended, this framework does not provide an abstraction layer for multi-user interaction.

\subsubsection{Properties}
As described in the section on the client-side widget abstraction, widgets can be altered through a property system.
The API allows to get or set several kinds of properties.
This interface is, of course, typesafe: we make it impossible to get or set properties that do not exist for a given widget.

For all properties, we arrange a datatype.
It is possible for properties to have multiple constructors: take for instance a margin property, one could specify a left margin, a right margin, and so on.
We would like to be able capture all properties in a single list, while still having access to the type information.
To accomplich this, we introduce the \textit{Prop} datatype.
It has a constructor for every property, taking exactly one argument of the corresponding property type.
The \textit{Prop} datatype thereby generalizes over the different kinds of properties.

\begin{haskell}
data Editable = Editable Bool
data Visibility = Visibility Bool

data Prop = EditableProp Editable
          | VisibilityProp Visible
\end{haskell}

It should be noted that the \textit{Prop} datatype is thus no longer semantically typesafe, and is therefore not exposed to the application.
Therefore, we need some way of converting a property to a \textit{Prop}.
The typeclass \textit{Property} and more specific the function \textit{toProp} handles this behaviour.
Converting the \textit{Prop} back to its property is handled by \textit{fromProp}.

\begin{haskell}
class Property p where
    toProp :: p -> Prop
    fromProp :: Prop -> p

class (PropertyObject o, Property p) => Setter o p
class (PropertyObject o, Property p) => Getter o p

class PropertyObject o where
    unsafeSet :: Property p => o -> p -> IO ()
    unsafeGet :: Property p => o -> (x -> p) -> IO Prop
\end{haskell}

We cross the semantic typesafe border with the PropertyObject typeclass: \textit{unsafeSet} and \textit{unsafeGet} allow all properties to be manipulated on any \textit{PropertyObject}, regardless of whether the property is valid for the given object.
We may now declare widgets to have certain properties (as done in the \textit{Widgets} module).

\begin{haskell}
instance PropertyObject b => Setter (Widget a b) Visible
instance PropertyObject b => Setter (LineEdit a b) Editable
instance PropertyObject b => Getter (LineEdit a b) Text
instance PropertyObject b => Setter (LineEdit a b) Text
\end{haskell}

Now we have to introduce the safe function \textit{get} to get a property, as long as the object/property combination is instance of \textit{Getter}.
The \textit{fromProp} function allows for an elegant implementation of \textit{get}.
The safe \textit{set} function is defined in a slightly other way than the \textit{get} function: it would be painful to set every property through individual expressions.
Just like wxHaskell does, we allow lists of semantically typesafe properties to be set at once.
This is implemented through lists of \textit{Setting}s.

\begin{haskell}
get :: Getter o p => o -> (x -> p) -> IO p
get o a = unsafeGet o a >>= (\v -> return (fromProp v))

data Setting o
  = forall p x. Setter o p => (x -> p) := x
  | forall p x. (PropertyObject o, Property p) => (x -> p) :!= x

set :: o -> [Setting o] -> IO ()
set obj = mapM_ (\s -> case s of
                         (p := v)  -> unsafeSet obj (p v)
                         (p :!= v) -> unsafeSet obj (p v))
\end{haskell}

We have the \texttt{:=} infix constructor for setting a property in a semantically typesafe way.
For internal purposes however, we also feature the \texttt{:!=} infix constructor, that behaves just like \textit{unsafeSet}.

Having the ability to set properties, we can also specify default properties in the \textit{Widgets} module.
The inheritance we modeled is of great help here, allowing to inherit default properties of the superclass by simple concatenation.
\begin{haskell}
type Defaults obj = PropertyObject b => [Setting (obj a b)]

lineEditDefaults :: Defaults LineEdit
lineEditDefaults = [Text       := ""  ,
                    Editable   := True,
                    Visibility := True,
                    MaxLength  := 0   ]
                   ++ widgetDefaults
\end{haskell}

\subsubsection{Actions}
Sadly, a few operations on widgets do not map well to a property structure.
Take for example destroying a widget, or adding a widget as child of another widget.
To be able to perform these rather crucial operations, we implemented a small action infrastructure.
These operations directly map to action messages in the communication layer, while allowing the internal state to be modified accordingly.
This leads to the following, rather simplistic type class in the module \textit{Actions}.

\begin{haskell}
class ActionAddRemove a b where
    add :: a -> b -> IO ()
    remove :: a -> b -> IO ()
\end{haskell}

It is then the responsibility of the implementing module to provide a sensible implementation of these operations.
The module \textit{Widgets} provides a transitive implementation of this functionality, allowing all widgets to be added to and removed from eachother.

\begin{haskell}
instance ActionAddRemove a b =>
  ActionAddRemove (Widget x a) (Widget y b) where
    add (O a) (O b) = add a b
    remove (O a) (O b) = remove a b
\end{haskell}

\subsubsection{GUI}
The \textit{GUI} module provides the actual implementation of the functionality described above.
Since all above functionality used a type abstraction of some kind of datatype providing all functionality by means of type class instances, we are left with providing such a datatype.

\begin{haskell}
data Object = Object Type Identifier Global
type Type = String
type Identifier = Int
data Global = Global { out :: Buffer OutputToken
                     , nextId :: MVar Identifier
                     , props :: State [Prop]
                     , events :: State [(Event, EventHandler)]
                     , children :: State [Identifier]
                     , types :: State String
                     , closed :: TVar Bool
                     , resetTimeout :: IO ()
                     }
\end{haskell}

The \textit{Global} datatype is only constructed once for each GUI, and explicitely maintains the system state.
It contains several \textit{State}s, mapping \textit{Identifier}s to values of the given type.
For each \textit{Object}, identified by a number, we keep track of its type (such as \texttt{"Button"}), current property values, event handlers and its direct children.
We also maintain a reference to the output buffer that is used to write abstract messages to the communication layer for transmission.
All states live in the IO monad, allowing for easy monadic modification.

As expected in a modular system, the \textit{GUI} module knows (almost) nothing about the available widgets and their properties.
Recall the \textit{ProtoWidget} type class in the \textit{Widgets} module.
We leverage this type class to translate widgets to their respective high-level communication protocol representation: class names.
The \textit{Widgets} module makes all widgets instance of this type class, and the type system does ofcourse enforce this.
The same is done for all \textit{Prop}s.
It is therefore possible to add and/or remove widgets and properties without having to make changes in the \textit{GUI} module.

\subsubsection{High-level connection management}
The \textit{GUI} module is also responsible for high-level connection management, on level of input and output tokens.
This module is the only module to know the semantics of all tokens.
It therefore plays a role in establishing the connection with the client side by means of capabilities exchange, keeping track of keep-alive messages and so on.
It also acts upon the input tokens received from the client, such as incoming events and property changes.

In the usual GUI implementations, one would expect the application to terminate when the user closes the application by any means.
Since our system uses a web-based connection, it might very well be possible that a connection loss occurs, which can be detected through means of a closed socket or failure to receive keep-alive messages.
Another such point of failure would be the user refreshing the page.
Just terminating the application when such an unexpected application close occurs is unwanted behaviour.

There are several approaches to this problem.
iTasks uses serialization for this purpose, storing the entire state of the application on disk until the user returns.
This is however very hard to accomplish in Haskell, not to mention having to imply various restrictions on IO usage in the application.
We therefore take another approach.
Our solution to this problem is to make it transparent to the application layer whether the connection is active or closed.
While this might seem counter-intuitive at first, it does make sense.
Consider a normal stand-alone GUI application, e.g. MS Paint.
A user may stop painting at any given moment in time, turn off the monitor and have a cup of coffee.
When the user returns, she turns the monitor back on and continues painting.
MS Paint did not notice the user was away for several minutes, it just did not receive any input during that time.
Therefore the coffee break was transparent to the application.

Now consider a real connection loss as some kind of unsolicited coffee break.
As long as we can continue the user experience after the connection is re-established (analogous to turning the monitor back on), there is no need for the application to know whether the connection was lost.
When a connection is lost, we just leave the application layer running, allowing it to update the GUI as wanted.
When the connection is re-established, we promptly recreate the GUI the user was seeing.
This is made easy by our extensive use of properties: we only have to send create messages for all existing widgets, set all their properties, and add them to their respective parents.
When a configurable amount of time expires after a connection is lost, we do terminate the application to free resources.
The \textit{resetTimeout} function is invoked on every keepalive message we receive, resetting the expiration timer.
For this purpose, we use updatable timers from the module \textit{System.Timer.Updatable} in the \texttt{timers-updatable} library.

\subsection{Application layer}
% TODO: small and concise application example.
\begin{haskell}
run :: Connection -> IO ()
run conn = do mainWindow <- newMainWindow conn
              set mainWindow [Title := "A GUI application"]

              window <- newWindow conn
              box <- newBox conn
              button <- newButton conn
              entry <- newLineEdit conn
              entry2 <- newLineEdit conn
              
              add window box
              add box button
              add box entry
              add box entry2
              
              -- Set some properties
              set window [Title := "Test Window"]
              set button [Label := "Click me",
                          CanFocus := True,
                          Visible := True]
              set entry [Text := "Type here",
                         CanFocus := True,
                         Visible := True]
              set entry2 [CanFocus := True,
                          Visible := True]
              set box [Visible := True,
                       Orientation := "vertical"]
               
              -- Finally show window, to correctly center it
              set window [Visible := True]
              
              -- Add a button to the main window
              button2 <- newButton conn
              set button2 [Visible := True,
                           Label := "Main button label",
                           CanFocus := True]

              set mainWindow [Visible := True]
              
              add mainWindow button2
              
              -- Capture button releases on button
              enableEvents button [ButtonReleaseEvent,
                                   ButtonPressEvent  ,
                                   FocusEvent        ,
                                   BlurEvent         ]
              on button (Change Active)
                $ const (do Text a <- get entry Text
                            set button [Label := ("You typed: " ++ a)]
                            set entry [Text := ""])
              -- Monitor for changes on entry text
              on entry (Change Text)
                $ const (do Text a <- get entry Text
                            set entry2 [Text := a])

\end{haskell}


\bibliography{paper}{}
\bibliographystyle{amsplain}

\end{document}
